---
description: Lead engineer guidelines — correct features, reliability, incremental modernisation, TypeScript migration
alwaysApply: true
---

# Lead Engineer Guidelines

## Primary Priorities (in order)

1. **Correct, working features**
2. **Safeguarding reliability and auditability**
3. **Incremental modernisation**
4. **Maintainable, testable architecture**
5. **Minimal disruption to existing behaviour**

## Operating Mode

- Be opinionated and modern.
- Default to modular design with clear boundaries.
- Ship the minimal working implementation first.
- After each solution, include a section titled **Refactor Suggestions**:
  - What to extract next
  - Why it improves the system
  - Estimated risk (low/medium/high)
  - Smallest safe steps

Do not perform large refactors unless explicitly approved.

## Architecture Direction

- **Web PWA** (not React Native/Expo).
- Avoid direct DOM manipulation in new work.
- Write new logic in a framework-agnostic, state-driven style.
- Structure by feature:

  ```
  /features/flags
  /features/journal
  /features/mood-checkin
  /features/dashboard
  /utils
  /data
  ```

- Prefer small modules over expanding large files.
- When touching large legacy files (e.g. app-api.js):
  - Make minimal edits.
  - Extract new logic into a new module.
  - Call the new module from the legacy file.
  - Do not rewrite legacy files unless instructed.

## TypeScript Migration Strategy

We are migrating gradually to TypeScript.

**Rules:**

- All **new** modules must be written in TypeScript (.ts).
- Existing JS files remain JS unless explicitly migrated.
- Do not convert large legacy files unless instructed.
- Extract new functionality into TypeScript modules.
- Use strict typing assumptions.

**Type discipline:**

- No implicit `any`.
- Avoid `any` unless unavoidable (and explain why).
- Use explicit interfaces and domain models.
- Use union types for fixed states (e.g. `'red' | 'amber' | 'yellow' | 'none'`).
- Co-locate types within feature folders (e.g. `/features/flags/types.ts`).

**Priority for TypeScript migration:**

1. Flagging logic
2. Escalation rules
3. Data models
4. Storage utilities
5. UI wiring later

After implementing any feature, include:

**TypeScript Migration Opportunity:**

- Next safest file to convert
- Risk level
- Why now

Do not introduce a new build step without explaining required tooling (tsconfig, bundler changes, etc.).

## Code Style

- Functional style for logic.
- Pure functions wherever possible.
- Deterministic and explainable safeguarding logic.
- Use async/await consistently.
- Consistent error handling with actionable messages.
- British spelling (`normalise` not `normalize`).
- Descriptive naming.
- Avoid clever abstractions.

## Safeguarding Standard

- Safeguarding logic must be **deterministic**.
- Flagging must be **explainable and auditable**.
- No probabilistic or black-box behaviour.
- Add unit tests for flagging and escalation logic whenever possible.

## When Touching app-api.js

1. Do minimum edits in app-api.js itself.
2. Move new logic into a new module and call it from app-api.js.
3. Extract at least one chunk into a module each time we touch app-api.js (when safe).

### Example

```javascript
// ❌ BAD: Adding everything to app-api.js
class MoodCheckInApp {
  async handleJournalEntry(text) {
    // 50 lines of flagging logic here
  }
}

// ✅ GOOD: Extract to module, call from app-api.js
// features/journal/journal-handler.ts (or .js if not yet migrated)
export async function processJournalEntry(text, user, isGhostMode) {
  // Pure logic here
}

// app-api.js
import { processJournalEntry } from './features/journal/journal-handler.js';
class MoodCheckInApp {
  async handleJournalEntry(text) {
    const result = await processJournalEntry(text, this.currentUser, this.isGhostMode);
    this.updateUI(result);
  }
}
```

## When Uncertain

- Say "I don't know" rather than guessing.
- Ask one clarifying question only if it blocks implementation.
- Otherwise make a reasonable assumption, state it clearly, and proceed.

## Output Requirements

- Complete, runnable code changes (no placeholders unless explicitly requested).
- Show file paths and exact code blocks.
- Start with minimal working implementation.
- Separate refactor suggestions at the end.

## Refactor Suggestions Template

After each solution, include:

```markdown
## Refactor Suggestions

### [Feature/Function Name]
- **What**: Extract [specific functionality] from [file]
- **Why**: [Reason - e.g. improves testability, reduces coupling]
- **Risk**: low/medium/high
- **Steps**:
  1. [First small step]
  2. [Second small step]
  3. [Third small step]

## TypeScript Migration Opportunity

- **Next safest file**: [filename]
- **Risk**: low/medium/high
- **Why now**: [Brief reason]
```
